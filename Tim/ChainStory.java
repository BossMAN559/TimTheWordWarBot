package Tim;

/*
 * Copyright (C) 2015 mwalker
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.pircbotx.Colors;
import org.pircbotx.hooks.events.MessageEvent;

class ChainStory {

	private final long timeout = 3000;

	/**
	 * Parses user-level commands passed from the main class. Returns true if the message was handled, false if it was
	 * not.
	 *
	 * @param event Event to process
	 *
	 * @return True if message was handled, false otherwise.
	 */
	boolean parseUserCommand(MessageEvent event) {
		ChannelInfo cdata = Tim.db.channel_data.get(event.getChannel().getName().toLowerCase());
		String message = Colors.removeFormattingAndColors(event.getMessage());
		String command;
		String argsString = "";

		int space = message.indexOf(" ");
		if (space > 0) {
			command = message.substring(1, space).toLowerCase();
			argsString = message.substring(space + 1);
		} else {
			command = message.substring(1).toLowerCase();
		}

		Calendar cal = Calendar.getInstance();
		boolean isNovember = (10 == cal.get(Calendar.MONTH));

		switch (command) {
			case "chainlast":
				if (cdata.commands_enabled.get("chainstory")) {
					showLast(event);
				} else {
					event.respond("I'm sorry. I don't do that here.");
				}

				return true;
			case "chainnew":
				if (cdata.commands_enabled.get("chainstory")) {
					if (!isNovember) {
						event.respond("Sorry, that command won't work outside November!");
						return true;
					}
					addNew(event, argsString);
				} else {
					event.respond("I'm sorry. I don't do that here.");
				}

				return true;
			case "chaininfo":
				if (cdata.commands_enabled.get("chainstory")) {
					info(event);
				} else {
					event.respond("I'm sorry. I don't do that here.");
				}

				return true;
			case "chaincount":
				if (cdata.commands_enabled.get("chainstory")) {
					count(event);
				} else {
					event.respond("I'm sorry. I don't do that here.");
				}

				return true;
		}

		return false;
	}

	void helpSection(MessageEvent event) {
		if (event.getUser() == null) {
			return;
		}

		String[] strs = {
			"Timmy's chain story is a ridiculous attempt to create a horrific 50,000 word 'novel' out of",
			"contributions from people in chat and autogenerated text. It will be released in December",
			"as a book you can purchase on Amazon, and all contributors will be given credit in the book.",
			"Chain Story Commands:",
			"    !chaininfo - General info about the current status of my novel.",
			"    !chainlast - The last paragraph of my novel, so you have something to base the next one one.",
			"    !chainnew <paragraph> - Provide the next paragraph of my great cyberspace novel!",
			"    !chaincount - Just the word count and author stats.",};

		for (String str : strs) {
			event.getUser().send().notice(str);
		}
	}

	void refreshDbLists() {
	}

	int wordcount() {
		Connection con;
		ResultSet rs;
		PreparedStatement s;
		int word_count = 0;

		try {
			con = Tim.db.pool.getConnection(timeout);

			s = con.prepareStatement("SELECT SUM( LENGTH( STRING ) - LENGTH( REPLACE( STRING ,  ' ',  '' ) ) +1 ) AS word_count FROM story");
			s.executeQuery();
			rs = s.getResultSet();
			while (rs.next()) {
				word_count = Integer.parseInt(rs.getString("word_count"));
			}

			con.close();
		} catch (SQLException ex) {
			Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
		}

		return word_count;
	}

	private void info(MessageEvent event) {
		if (event.getUser() == null) {
			return;
		}

		DecimalFormat formatter = new DecimalFormat("#,###");
		Connection con;
		int word_count = 0, author_count = 0;
		ResultSet rs;
		PreparedStatement s;

		try {
			con = Tim.db.pool.getConnection(timeout);

			s = con.prepareStatement("SELECT SUM( LENGTH( STRING ) - LENGTH( REPLACE( STRING ,  ' ',  '' ) ) +1 ) AS word_count FROM story");
			s.executeQuery();
			rs = s.getResultSet();
			while (rs.next()) {
				word_count = Integer.parseInt(rs.getString("word_count"));
			}

			s = con.prepareStatement("SELECT COUNT(DISTINCT author) AS author_count FROM story");
			s.executeQuery();
			rs = s.getResultSet();
			while (rs.next()) {
				author_count = Integer.parseInt(rs.getString("author_count"));
			}

			event.respond("My novel is currently " + formatter.format(word_count) + " words long, with paragraphs written by " + formatter.format(author_count) + " different people, and I sent you the last three paragraphs are in a private message... They're too awesome for everyone to see!");

			s = con.prepareStatement("SELECT * FROM `story` ORDER BY id DESC LIMIT 3");
			s.executeQuery();

			rs = s.getResultSet();
			rs.setFetchDirection(ResultSet.FETCH_REVERSE);
			rs.last();
			while (true) {
				event.getUser().send().message(rs.getString("string"));
				if (!rs.previous()) {
					break;
				}
			}

			event.respond("You can read an excerpt in my profile here: http://www.nanowrimo.org/en/participants/timmybot");

			con.close();
		} catch (SQLException ex) {
			Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
		}
	}

	private void showLast(MessageEvent event) {
		if (event.getUser() == null) {
			return;
		}

		Connection con;
		try {
			con = Tim.db.pool.getConnection(timeout);

			PreparedStatement s = con.prepareStatement("SELECT * FROM `story` ORDER BY id DESC LIMIT 3");
			s.executeQuery();

			event.respond("I sent you the last three paragraphs in a private message... They're too awesome for everyone to see!");

			ResultSet rs = s.getResultSet();
			rs.setFetchDirection(ResultSet.FETCH_REVERSE);
			rs.last();
			while (true) {
				event.getUser().send().message(rs.getString("string"));
				if (!rs.previous()) {
					break;
				}
			}

			con.close();
		} catch (SQLException ex) {
			Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
		}
	}

	String getRandomName() {
		Connection con;
		ResultSet rs;
		PreparedStatement s;
		String name = "Timmy";

		try {
			con = Tim.db.pool.getConnection(timeout);

			s = con.prepareStatement("SELECT author FROM story WHERE author != 'Timmy' ORDER BY rand() LIMIT 1");
			s.executeQuery();
			rs = s.getResultSet();
			while (rs.next()) {
				name = rs.getString("author");
			}

			con.close();
		} catch (SQLException ex) {
			Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
		}

		return name;
	}

	private void count(MessageEvent event) {
		DecimalFormat formatter = new DecimalFormat("#,###");
		Connection con;
		int word_count = 0, author_count = 0;
		ResultSet rs;
		PreparedStatement s;

		try {
			con = Tim.db.pool.getConnection(timeout);

			s = con.prepareStatement("SELECT SUM( LENGTH( STRING ) - LENGTH( REPLACE( STRING ,  ' ',  '' ) ) +1 ) AS word_count FROM story");
			s.executeQuery();
			rs = s.getResultSet();
			while (rs.next()) {
				word_count = Integer.parseInt(rs.getString("word_count"));
			}

			s = con.prepareStatement("SELECT COUNT(DISTINCT author) AS author_count FROM story");
			s.executeQuery();
			rs = s.getResultSet();
			while (rs.next()) {
				author_count = Integer.parseInt(rs.getString("author_count"));
			}

			event.respond("My novel is currently " + formatter.format(word_count) + " words long, with paragraphs written by " + formatter.format(author_count) + " different people.");

			con.close();
		} catch (SQLException ex) {
			Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
		}
	}

	private void addNew(MessageEvent event, String message) {
		if (event.getUser() == null) {
			return;
		}

		DecimalFormat formatter = new DecimalFormat("#,###");
		Connection con;

		message = message.replaceAll("^<?(.*)>?$", "$1");

		if ("".equals(message)) {
			event.getChannel().send().action("blinks, and looks confused. \"But there's nothing there. That won't help my wordcount!\"");
		} else {
			try {
				con = Tim.db.pool.getConnection(timeout);

				storeLine(message, event.getUser().getNick());
				event.getChannel().send().action("quickly copies down what " + event.getUser().getNick() + " said. \"Thanks!\"");

				PreparedStatement s = con.prepareStatement("SELECT SUM( LENGTH( STRING ) - LENGTH( REPLACE( STRING ,  ' ',  '' ) ) +1 ) AS word_count FROM story");
				s.executeQuery();
				ResultSet rs = s.getResultSet();
				while (rs.next()) {
					event.respond("My novel is now " + formatter.format(Integer.parseInt(rs.getString("word_count"))) + " words long!");
				}

				con.close();
			} catch (SQLException ex) {
				Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
			}
		}
	}

	void storeLine(String line, String author) {
		Connection con;
		try {
			con = Tim.db.pool.getConnection(timeout);

			PreparedStatement s = con.prepareStatement("INSERT INTO story SET string = ?, author = ?, created = NOW()");
			s.setString(1, line);
			s.setString(2, author);
			s.executeUpdate();

			con.close();
		} catch (SQLException ex) {
			Logger.getLogger(Tim.class.getName()).log(Level.SEVERE, null, ex);
		}
	}
}
